# KAFKA MONGODB OUTBOX REMOVER

This is a Kafka Consumer application which is part of a implementation of [Transactional Outbox pattern](https://microservices.io/patterns/data/transactional-outbox.html) with MongoDB and Kafka.

## DEPRECATION NOTE

This application is deprecated for incompatibility with [Outbox Transformer](https://github.com/marlonpatrick/kafka-mongodb-outbox-transformer) in the input message format.

This incompatibility occur especially because the use of `output.json.formatter=com.mongodb.kafka.connect.source.json.formatter.SimplifiedJson` required by Outbox Transformer. While Outbox Remover requires `output.json.formatter=com.mongodb.kafka.connect.source.json.formatter.ExtendedJson`

See that StackOverflow [question](https://stackoverflow.com/questions/65055761/there-is-a-out-of-box-way-to-convert-a-simplifiedjson-to-a-bson) to better understand the problem.

In the moment, the best way to clean up your "outbox" field is to handle that in the same application which populate the field or create a batch job to do that.

## High level overview

1. Applications save data in MongoDB and add a "outbox" array field with messages that will be published to Kafka. Example:

```javascript
{
   "_id":"4c152a44-f49e-44f8-b266-5e79644f1513",
   "text":"this is an arbitraty field",
   "outbox":[
      {
         "_id":"c24497c5-4ac2-4502-8f54-8d981c8b1578",
         "createdAt":"2020-11-28T16:38:31.097Z",
         "entityName":"MyEntity",
         "entityId":"4c152a44-f49e-44f8-b266-5e79644f1513",
         "messageName":"MyEntityCreatedEvent",
         "targetTopic":"kafka.target.topic.name",
         "payload":{
            // Here, you put anything you want
            "text":"this is an arbitraty field"
         }
      }
   ]
}
```

2. Via Kafka Connect and MongoDB Kafka Connector, documents inserted/replaced/updated and containing a non-empty "outbox" array field will be published to Kafka in a first stage topic, let's call that topic "cdc.mongodb.outbox".

3. In parallel, two applications will consume and process the previous topic "cdc.mongodb.outbox":

   3.1. The [Outbox Transformer](https://github.com/marlonpatrick/kafka-mongodb-outbox-transformer) kafka streams application: the output will be one message for each element in the "outbox" array field in the original document. The destination topic for each message is determined by the field "targetTopic" in the outbox message. **These output messages are the final messages ready to be consumed by others client applications/microservices.**

   3.2. **This Kafka Consumer application (Outbox Remover)**: the goal is to catch all outbox messages that arrived in Kafka and remove that specifics outbox messages in the corresponding MongoDB database/collection/document. Thus, the "outbox" array field is always kept small in MongoDB document.

## Input Message Formats

There are two expected input message formats: one for insert/replace operations and other for update operations.

Both are generated by the MongoDB Kafka Connector through the correct settings.

1. Insert or Replace operations minimal input message format example

```json
{
  "operationType":"insert|replace",
  "fullDocument": {
    "outbox": [
        {"_id": {}}
    ]
  },
  "ns": {
    "db": "databaseName",
    "coll": "collectionName"
  },
  "documentKey": {
    "_id": {}
  }
}
```

2. Update operations minimal input message format example

```json
{
  "operationType":"update",
  "updateDescription":{
    "updatedFields": {
      "outbox": [
          {"_id": {}}
      ]
    },
  },
  "ns": {
    "db": "databaseName",
    "coll": "collectionName"
  },
  "documentKey": {
    "_id": {}
  }
}
```

## Input Message Key

It's recomended to use the original document _id as the message key.

## MongoDB Kafka Connector (v1.3) settings

Here is a minimal settings to produce messages in correct formats:

```properties

connector.class=com.mongodb.kafka.connect.MongoSourceConnector

# The will generate a json message in BSON format. 
# That way, field types will be recongnized correctly, especially, _id fields.
output.json.formatter=com.mongodb.kafka.connect.source.json.formatter.ExtendedJson

# When operationType=update, fullDocument is empty and only a delta describing the changes
# will be appended in the message
change.stream.full.document=default

# Original message key will be in avro format
output.format.key=schema

# That message key avro format put the original document _id in the message key
# Will generate a value like {"documentKey": {"_id": {"$binary": {"base64": "/lxhiTEbSE+w6e/cWd6zVg==", "subType": "04"}}}}
output.schema.key={ "name":"DocumentKey", "type":"record", "namespace":"outbox.mongodb.avro", "fields": [ {"name": "documentKey", "type": {"name": "documentKeyField","type": "record", "fields": [ { "name":"_id","type": "string"} ] } }] }

# Work's with output.json.formatter=ExtendedJson
output.format.value=json

# The message value will be a simple string instead a avro or json schema
value.converter=org.apache.kafka.connect.storage.StringConverter

# This pipeline filter the supported operations and ensures the correct schema,
# either in the insert/replace or in the update operations
# Here https://docs.mongodb.com/kafka-connector/v1.3/kafka-source there is a 
# pipeline example to filter source database and collections
pipeline=[{"$match":{"operationType": {"$in":[ "insert", "replace", "update"]}}}, {"$match": {"$or": [{"fullDocument.outbox":{"$exists":"true", "$type":"array", "$ne":[]} }, {"updateDescription.updatedFields.outbox":{"$exists":"true", "$type":"array", "$ne":[]}}]}}, {"$match":{"$or": [{"fullDocument.outbox._id":{"$exists":"true"}}, {"updateDescription.updatedFields.outbox._id":{"$exists":"true"}}]}},{"$match":{"$or": [{"fullDocument.outbox.createdAt":{"$exists":"true"}}, {"updateDescription.updatedFields.outbox.createdAt":{"$exists":"true"}}]}},{"$match":{"$or": [{"fullDocument.outbox.entityName":{"$exists":"true" }}, {"updateDescription.updatedFields.outbox.entityName":{"$exists":"true" }}]}}, {"$match":{"$or": [{"fullDocument.outbox.entityId":{"$exists":"true" }}, {"updateDescription.updatedFields.outbox.entityId":{"$exists":"true" }}]}},{"$match":{"$or": [{"fullDocument.outbox.messageName":{"$exists":"true"}}, {"updateDescription.updatedFields.outbox.messageName":{"$exists":"true"}}]}}, {"$match":{"$or": [{"fullDocument.outbox.payload":{"$exists":"true" }}, {"updateDescription.updatedFields.outbox.payload":{"$exists":"true" }}]}}]
```
